While it might seem handy to be able to extract the concrete implementation from an
interface variable, you should use these techniques infrequently. For the most part,
treat a parameter or return value as the type that was supplied and not what else it
could be. Otherwise, your function’s API isn’t accurately declaring what types it needs
to perform its task. If you needed a different type, then it should be specified.
That said, there are use cases where type assertions and type switches are useful. One
common use of a type assertion is to see if the concrete type behind the interface also
implements another interface. This allows you to specify optional interfaces. For
example, the standard library uses this technique to allow more efficient copies when
the io.Copy function is called. This function has two parameters of types io.Writer
and io.Reader and calls the io.copyBuffer function to do its work. If the io.Writer
parameter also implements io.WriterTo , or the io.Reader parameter also imple‐
ments io.ReaderFrom , most of the work in the function can be skipped
In Go 1.8, new context-aware analogues of existing interfaces were defined in the
database/sql/driver package. For example, the StmtExecContext interface defines
a method called ExecContext , which is a context-aware replacement for the Exec
method in Stmt . When an implementation of Stmt is passed into standard library
database code, it checks to see if it also implements StmtExecContext . If it does,
ExecContext is invoked. If not, the Go standard library provides a fallback imple‐
mentation of the cancellation support provided by newer code:
func ctxDriverStmtExec(ctx context.Context, si driver.Stmt,
nvdargs []driver.NamedValue) (driver.Result, error) {
if siCtx, is := si.(driver.StmtExecContext); is {
return siCtx.ExecContext(ctx, nvdargs)
}
// fallback code is here
}
There is one drawback to the optional interface technique. We saw earlier that it
is common for implementations of interfaces to use the decorator pattern to wrap
other implementations of the same interface to layer behavior. The problem is that if
there is an optional interface implemented by one of the wrapped implementations,
you cannot detect it with a type assertion or type switch. For example, the standard
library includes a bufio package that provides a buffered reader. You can buffer any
other io.Reader implementation by passing it to the bufio.NewReader function and
using the returned *bufio.Reader . If the passed-in io.Reader also implemented
io.ReaderFrom , wrapping it in a buffered reader prevents the optimization.
We also see this when handling errors. As mentioned earlier, they implement the
error interface. Errors can include additional information by wrapping other errors.
A type switch or type assertion cannot detect or match wrapped errors. If you want
different behaviors to handle different concrete implementations of a returned error,
use the errors.Is and errors.As functions to test for and access the wrapped error.
Type switch statements provide the ability to differentiate between multiple imple‐
mentations of an interface that require different processing. They are most useful
when there are only certain possible valid types that can be supplied for an interface.
Be sure to include a default case in the type switch to handle implementations that
aren’t known at development time. This protects you if you forget to update your type
switch statements when adding new interface implementations:
func walkTree(t *treeNode) (int, error) {
switch val := t.val.(type) {
case nil:
return 0, errors.New("invalid expression")
case number:
// we know that t.val is of type number, so return the
// int value
    When you are ready to publish your new code, place a tag on your repository that
looks like vN.0.0. If you are using the subdirectory system or keeping the latest code
on your main branch, tag the main branch. If you are placing your new code on a
different branch, tag that branch instead.
You can find more details on updating your code to an incompatible version in the
post Go Modules: v2 and Beyond on the Go Blog.
Module Proxy Servers
Rather than rely on a single, central repository for libraries, Go uses a hybrid model.
Every Go module is stored in a source code repository, like GitHub or GitLab. But by
default, go get doesn’t fetch code directly from source code repositories. Instead, it
sends requests to a proxy server run by Google. This server keeps copies of every ver‐
sion of virtually all public Go modules. If a module or a version of a module isn’t
present on the proxy server, it downloads the module from the module’s repository,
stores a copy, and returns the module.
In addition to the proxy server, Google also maintains a sum database. It stores infor‐
mation on every version of every module. This includes the entries that appear in a
go.sum file for the module at that version and a signed, encoded tree description that
200
| Chapter 9: Modules, Packages, and Importscontains the record. Just as the proxy server protects you from a module or a version
of a module being removed from the internet, the sum database protects you against
modifications to a version of a module. This could be malicious (someone has
hijacked a module and slipped in malicious code), or it could be inadvertent (a mod‐
ule maintainer fixes a bug or adds a new feature and reuses an existing version tag).
In either case, you don’t want to use a module version that has changed because you
won’t be building the same binary and don’t know what the effects are on your
application.
Every time you download a module via go build , go test , or go get , the Go tools
calculate a hash for the module and contact the sum database to compare the calcula‐
ted hash to the hash stored for that module’s version. If they don’t match, the module
isn’t installed.
Specifying a Proxy Server
Some people object to sending requests for third-party libraries to Google. There are
a few options:
• If you don’t mind a public proxy server, but don’t want to use Google’s, you can
switch to GoCenter (which is run by JFrog) by setting the GOPROXY environment
variable to https://gocenter.io,direct.
• You can disable proxying entirely by setting the GOPROXY environment variable to
direct . You’ll download modules directly from their repositories, but if you
depend on a version that’s removed from the repository, you won’t be able to
access it.
• You can run your own proxy server. Both Artifactory and Sonatype have Go
proxy server support built into their enterprise repository products. The Athens
Project provides an open source proxy server. Install one of these products on
your network and then point GOPROXY to the URL.
Private Repositories
Most organizations keep their code in private repositories. If you want to use a pri‐
vate module in another Go project, you can’t request it from Google’s proxy server.
Go will fall back to checking the private repository directly, but you might not want
to leak the names of private servers and repositories to external services.
If you are using your own proxy server, or if you have disabled proxying, this isn’t an
issue. Running a private proxy server has some additional benefits. First, it speeds up
downloading of third-party modules, as they are cached in your company’s network.
If accessing your private repositories requires authentication, using a private proxy
server means that you don’t have to worry about exposing authentication information
Module Proxy Servers
|
201in your CI/CD pipeline. The private proxy server is configured to authenticate to
your private repositories (see the authentication configuration documentation for
Athens), while the calls to the private proxy server are unauthenticated.
If you are using a public proxy server, you can set the GOPRIVATE environment vari‐
able to a comma-separated list of your private repositories. For example, if you set
GOPRIVATE to:
GOPRIVATE=*.example.com,company.com/repo
Any module stored in a repository that’s located at any subdomain of example.com or
at a URL that starts with company.com/repo will be downloaded directly.
Wrapping Up
In this chapter, we’ve learned how to organize code and interact with the ecosystem of
Go source code. We’ve seen how modules work, how to organize your code into pack‐
ages, how to use third-party modules, and how to release modules of your own. In
the next chapter, we’re going to explore one of the signature features in Go:
concurrency.
202
|
Chapter 9: Modules, Packages, and ImportsCHAPTER 10
Concurrency in Go
Concurrency is the computer science term for breaking up a single process into inde‐
pendent components and specifying how these components safely share data. Most
languages provide concurrency via a library that uses operating system–level threads
that share data by attempting to acquire locks. Go is different. Its main concurrency
model, arguably Go’s most famous feature, is based on CSP (Communicating Sequen‐
tial Processes). It’s a style for concurrency that was described in 1978 in a paper by
Tony Hoare, the man who invented the Quicksort algorithm. The patterns imple‐
mented with CSP are just as powerful as the standard ones, but are far easier to
understand.
In this chapter, we are going to go through a quick review of the features that are the
backbone of concurrency in Go: goroutines, channels, and the select keyword. Then
we are going to look at some common Go concurrency patterns, and we will then
learn about the situations where lower-level techniques are a better approach.
When to Use Concurrency
Let’s start with a word of caution. Be sure that your program benefits from concur‐
rency. When new Go developers start experimenting with concurrency, they tend to
go through a series of stages:
1. This is amazing; I’m going to put everything in goroutines!
2. My program isn’t any faster. I’m adding buffers to my channels.
3. My channels are blocking and I’m getting deadlocks. I’m going to use buffered
channels with really big buffers.
4. My channels are still blocking. I’m going to use mutexes.
2035. Forget it, I’m giving up on concurrency.
People are attracted to concurrency because they believe concurrent programs run
faster. Unfortunately, that’s not always the case. More concurrency doesn’t automati‐
cally make things faster, and it can make code harder to understand. The key is
understanding that concurrency is not parallelism. Concurrency is a tool to better
structure the problem you are trying to solve. Whether or not concurrent code runs
in parallel (at the same time) depends on the hardware and if the algorithm allows it.
In 1967, Gene Amdahl, one of the pioneers of computer science, derived Amdahl’s
Law. It is a formula for figuring out how much parallel processing can improve per‐
formance, given how much of the work must be performed sequentially. If you want
to dive into the details on Amdahl’s Law, you can learn more in The Art of Concur‐
rency by Clay Breshears (O’Reilly). For our purposes, all you need to understand is
that more concurrency does not mean more speed.
Broadly speaking, all programs follow the same three-step process: they take data,
transform it, and then output the result. Whether or not you should use concurrency
in your program depends on how data flows through the steps in your program.
There are times when two steps can be concurrent because the data from one is not
required for the other to proceed, and there are other times when two steps must
happen in series because one depends on the other’s output. Use concurrency when
you want to combine data from multiple operations that can operate independently.
Another important thing to note is that concurrency isn’t worth using if the process
that’s running concurrently doesn’t take a lot of time. Concurrency isn’t free; many
common in-memory algorithms are so fast that the overhead of passing values via
concurrency overwhelms any potential time savings you’d gain by running concur‐
rent code in parallel. This is why concurrent operations are often used for I/O; read‐
ing or writing to a disk or network is thousands of times slower than all but the most
complicated in-memory processes. If you are not sure if concurrency will help, first
write your code serially, and then write a benchmark to compare performance with a
concurrent implementation. (See “Benchmarks” on page 283 for information on how
to benchmark your code.)
Let’s consider an example. Say you are writing a web service that calls three other web
services. We send data to two of those services, and then take the results of those two
calls and send them to the third, returning the result. The entire process must take
less than 50 milliseconds, or an error should be returned. This is a good use of con‐
currency, because there are parts of the code that need to perform I/O that can run
without interacting with each other, there’s a part where we combine the results, and
there’s a limit on how long our code needs to run. At the end of this chapter, we’ll see
how to implement this code.
204
|
Chapter 10: Concurrency in GoGoroutines
The goroutine is the core concept in Go’s concurrency model. To understand gorou‐
tines, let’s define a couple of terms. The first is process. A process is an instance of a
program that’s being run by a computer’s operating system. The operating system
associates some resources, such as memory, with the process and makes sure that
